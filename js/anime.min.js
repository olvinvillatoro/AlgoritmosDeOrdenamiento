/ ** *
http: //animejs.com
    *
    Motor de animación JavaScript *
    @version v2 .2 .0 *
    @autor Julian Garnier *
    @copyright© 2017 Julian Garnier *
    Publicado bajo la licencia MIT **
    /

(función(raíz, fábrica) {
    if (typeof define === 'función' && define.amd) {
        // AMD. Registrarse como un módulo anónimo.
        define([], fábrica);
    } else if (typeof module === 'objeto' && module.exports) {
        // Nodo No funciona con CommonJS estricto, pero
        // solo entornos de tipo CommonJS que admiten module.exports,
        // como Nodo.
        module.exports = factory();
    }
    más {
        // Globales del navegador (la raíz es la ventana)
        root.anime = factory();
    }
}(esto, () => {

    // valores predeterminados

    const defaultInstanceSettings = {
        actualización: indefinido,
        comenzar: indefinido,
        ejecutar: indefinido,
        completo: indefinido,
        bucle: 1,
        dirección: 'normal',
        reproducción automática: verdadero,
        desplazamiento: 0
    }

    const defaultTweenSettings = {
        duración: 1000,
        retraso: 0,
        easing: 'easeOutElastic',
        elasticidad: 500,
        ronda: 0
    }

    const validTransforms = ['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'skewX ', ' sesgado ', ' perspectiva '];
    deja transformString;

    // Utils

    función stringContains(str, text) {
        return str.indexOf(texto) > -1;
    }

    const es = {
        arr: a => Array.isArray(a),
        obj: a => stringContains(Object.prototype.toString.call(a), 'Object'),
        pth: a => is.obj(a) && a.hasOwnProperty('totalLength'),
        svg: a => una instancia de SVGElement,
        dom: a => a.nodeType || is.svg(a),
        str: a => typeof a === 'cadena',
        fnc: a => typeof a === 'función',
        und: a => typeof a === 'indefinido',
        hexadecimal: a => /(^#[0-9A-Ffont>{6}$)|(^#[0-9A-Ffont>{3}$)/i.test(a),
        rgb: a => /^rgb/.test(a),
        hsl: a => /^hsl/.test(a),
        col: a => (is.hex(a) || is.rgb(a) || is.hsl(a))
    }

    // BezierEasing https://github.com/gre/bezier-easing

    const bezier = (() => {

        const kSplineTableSize = 11;
        const kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

        función A(aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1 };
        función B(aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1 };
        función C(aA1) { return 3.0 * aA1 };

        función calcBezier(aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT };
        función getSlope(aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1) };

        función binarySubdivide(aX, aA, aB, mX1, mX2) {
            deje que currentX, currentT, i = 0;
            hacer {
                currentT = aA + (aB - aA) / 2.0;
                currentX = calcBezier(currentT, mX1, mX2) - aX;
                if (currentX > 0.0) { aB = currentT } else { aA = currentT };
            }
            while (Math.abs(currentX) > 0.0000001 && ++i < 10);
            return currentT;
        }

        función newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
            para(sea i = 0; i < 4; ++i) {
                const currentSlope = getSlope(aGuessT, mX1, mX2);
                if (currentSlope === 0.0) devuelve aGuessT;
                const currentX = calcBezier(aGuessT, mX1, mX2) - aX;
                aGuessT - = currentX / currentSlope;
            }
            devolver aGuessT;
        }

        función bezier(mX1, mY1, mX2, mY2) {

            if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) return;
            let sampleValues​​ = new Float32Array(kSplineTableSize);

            if (mX1! == mY1 || mX2! == mY2) {
                for (let i = 0; i < kSplineTableSize; ++i) {
                    sampleValues​​[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
                }
            }

            función getTForX(aX) {

                dejar intervaloStart = 0.0;
                let currentSample = 1;
                const lastSample = kSplineTableSize - 1;

                for (; currentSample! == lastSample && sampleValues​​[currentSample] <= aX; ++currentSample) {
                    intervalStart + = kSampleStepSize;
                }

                --currentSample;

                const dist = (aX - sampleValues​​[currentSample]) / (sampleValues​​[currentSample + 1] - sampleValues​​[currentSample]);
                const guessForT = intervalStart + dist * kSampleStepSize;
                const initialSlope = getSlope(guessForT, mX1, mX2);

                if (initialSlope > = 0.001) {
                    return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
                } else if (initialSlope === 0.0) {
                    return guessForT;
                }
                más {
                    return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
                }

            }

            volver x => {
                if (mX1 === mY1 && mX2 === mY2) devuelve x;
                if (x === 0) devuelve 0;
                if (x === 1) devuelve 1;
                return calcBezier(getTForX(x), mY1, mY2);
            }

        }

        volver bezier;

    })();

    constantes = (() => {

        const names = ['Quad', 'Cubic', 'Quart', 'Quint', 'Sine', 'Expo', 'Circ', 'Back', 'Elastic'];

        // Flexibilidad elástica adaptada de jQueryUI http://api.jqueryui.com/easings/

        función elástica(t, p) {
            devuelve t === 0 || t === 1 ? t :
                -Math.pow(2, 10 * (t - 1)) * Math.sin((((t - 1) - (p / (Math.PI * 2.0) * Math.asin(1))) * (Math.PI * 2)) / p);
        }

        // Ecuaciones aproximadas de Penner http://matthewlein.com/ceaser/

        ecuaciones constantes = {
            En: [
                [0.550, 0.085, 0.680, 0.530], / * InQuad * / [0.550, 0.055, 0.675, 0.190], / * InCubic * / [0.895, 0.030, 0.685, 0.220], / * InQuart * / [0.755, 0.050, 0.855, 0.060], / * InQuint * / [0.470, 0.000, 0.745, 0.715], / * InSine * / [0.950, 0.050, 0.795, 0.035], / * InExpo * / [0.600, 0.040, 0.980, 0.335], / * InCirc * / [0.600, -0.280, 0.735, 0.045], / * InBack * /
                elástico / * InElastic * /
            ],
            Fuera: [
                [0.250, 0.460, 0.450, 0.940], / * OutQuad * / [0.215, 0.610, 0.355, 1.000], / * OutCubic * / [0.165, 0.840, 0.440, 1.000], / * OutQuart * / [0.230, 1.000, 0.320, 1.000], / * OutQuint * / [0.390, 0.575, 0.565, 1.000], / * OutSine * / [0.190, 1.000, 0.220, 1.000], / * OutExpo * / [0.075, 0.820, 0.165, 1.000], / * OutCirc * / [0.175, 0.885, 0.320, 1.275], / * OutBack * /
                (t, f) => 1 - elástico(1 - t, f) / * OutElastic * /
            ],
            En fuera: [
                [0.455, 0.030, 0.515, 0.955], / * InOutQuad * / [0.645, 0.045, 0.355, 1.000], / * InOutCubic * / [0.770, 0.000, 0.175, 1.000], / * InOutQuart * / [0.860, 0.000, 0.070, 1.000], / * InOutQuint * / [0.445, 0.050, 0.550, 0.950], / * InOutSine * / [1.000, 0.000, 0.000, 1.000], / * InOutExpo * / [0.785, 0.135, 0.150, 0.860], / * InOutCirc * / [0.680, -0.550, 0.265, 1.550], / * InOutBack * /
                (t, f) => t < .5 ? elástico(t * 2, f) / 2 : 1 - elástico(t * -2 + 2, f) / 2 / * InOutElastic * /
            ]
        }

        let funciones = {
            lineal: bezier(0.250, 0.250, 0.750, 0.750)
        }

        para(escriba las ecuaciones) {
            ecuaciones[tipo].forEach((f, i) => {
                funciones['facilidad' + tipo + nombres[i]] = is.fnc(f) ? f : bezier.apply(esto, f);
            });
        }

        funciones de retorno;

    })();

    // Cuerdas

    función stringToHyphens(str) {
        return str.replace(/ ([az]) ([AZ]) /
            g, '$ 1- $ 2').toLowerCase();
    }

    función selectString(str) {
        if (is.col(str)) devuelve;
        tratar {
            dejar nodos = document.querySelectorAll(str);
            nodos de retorno;
        }
        captura(e) {
            regreso;
        }
    }

    // matrices

    función filterArray(arr, devolución de llamada) {
        const len​​ = arr.length;
        const thisArg = argumentos.length > = 2 ? argumentos[1] : nulo 0;
        dejar resultado = [];
        for (let i = 0; i < len; i++) {
            si(i in arr) {
                const val = arr[i];
                if (callback.call(thisArg, val, i, arr)) {
                    resultado.push(val);
                }
            }
        }
        resultado de retorno;
    }

    función flattenArray(arr) {
        return arr.reduce((a, b) => a.concat(is.arr(b) ? flattenArray(b) : b), []);
    }

    función toArray(o) {
        if (is.arr(o)) return o;
        if (is.str(o)) o = selectString(o) || o;
        if (o instanceof NodeList || o instanceof HTMLCollection) return [].slice.call(o);
        volver[o];
    }

    función arrayContains(arr, val) {
        return arr.some(a => a === val);
    }

    // Objetos

    función cloneObject(o) {
        dejar clonar = {};
        para(dejar p en o) clon[p] = o[p];
        clon de retorno;
    }

    función replaceObjectProps(o1, o2) {
        let o = cloneObject(o1);
        para(deje p en o1) o[p] = o2.hasOwnProperty(p) ? o2[p] : o1[p];
        volver o;
    }

    función mergeObjects(o1, o2) {
        let o = cloneObject(o1);
        para(deje p en o2) o[p] = is.und(o1[p]) ? o2[p] : o1[p];
        volver o;
    }

    // Colores

    función rgbToRgba(rgbValue) {
        const rgb = /rgb\((\d+,\s*[\dfont>+,\s*[\dfont>+)\)/g.exec(rgbValue);
        volver rgb ? `rgba ($ {rgb [1]}, 1)` : rgbValue;
    }

    función hexToRgba(hexValue) {
        const rgx = / ^ #? ([af \ d]) ([af \ d]) ([af \ d]) $ /
        i;
        const hex = hexValue.replace(rgx, (m, r, g, b) => r + r + g + g + b + b);
        const rgb = /^#?([af\dfont>{2})([af\dfont>{2})([af\dfont>{2})$/i.exec(hex);
        const r = parseInt(rgb[1], 16);
        const g = parseInt(rgb[2], 16);
        const b = parseInt(rgb[3], 16);
        devuelve `rgba ($ {r}, $ {g}, $ {b}, 1)`;
    }

    función hslToRgba(hslValue) {
        const hsl = /hsl\((\d+),\s*([\d.font>+)%,\s*([\d.font>+)%\)/g.exec(hslValue) || /hsla\((\d+),\s*([\d.font>+)%,\s*([\d.font>+)%,\s*([\d.font>+)\)/g .exec (hslValue);
        const h = parseInt(hsl[1]) / 360;
        const s = parseInt(hsl[2]) / 100;
        const l = parseInt(hsl[3]) / 100;
        const a = hsl[4] || 1;
        función hue2rgb(p, q, t) {
            si(t < 0) t + = 1;
            si(t > 1) t - = 1;
            if (t < 1 / 6) devuelve p + (q - p) * 6 * t;
            si(t < 1 / 2) devuelve q;
            if (t < 2 / 3) devuelve p + (q - p) * (2 / 3 - t) * 6;
            volver p;
        }
        dejar r, g, b;
        si(s == 0) {
            r = g = b = l;
        }
        más {
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
        }
        devuelve `rgba ($ {r * 255}, $ {g * 255}, $ {b * 255}, $ {a})`;
    }

    función colorToRgb(val) {
        if (is.rgb(val)) devuelve rgbToRgba(val);
        if (is.hex(val)) devuelve hexToRgba(val);
        if (is.hsl(val)) devuelve hslToRgba(val);
    }

    // Unidades

    función getUnit(val) {
        const split = /([\+\-font>?[0-9#\.font>+)(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin | vmax | deg | rad | turn)? $ /. exec (val);
        if (división) devuelve división[2];
    }

    función getTransformUnit(propName) {
        if (stringContains(propName, 'translate') || propName === 'perspective') return 'px';
        if (stringContains(propName, 'rotate') || stringContains(propName, 'skew')) return 'deg';
    }

    // Valores

    función minMaxValue(val, min, max) {
        return Math.min(Math.max(val, min), max);
    }

    function getFunctionValue(val, animatable) {
        if (!is.fnc(val)) devuelve val;
        return val(animatable.target, animatable.id, animatable.total);
    }

    función getCSSValue(el, prop) {
        if (accesorio en el.style) {
            return getComputedStyle(el).getPropertyValue(stringToHyphens(prop)) || '0';
        }
    }

    función getAnimationType(el, prop) {
        if (is.dom(el) && arrayContains(validTransforms, prop)) devuelve 'transform';
        if (is.dom(el) && (el.getAttribute(prop) || (is.svg(el) && el[prop]))) devuelve 'atributo';
        if (is.dom(el) && (prop! == 'transform' && getCSSValue(el, prop))) return 'css';
        if (el[prop] ! = null) devuelve 'objeto';
    }

    función getTransformValue(el, propName) {
        const defaultUnit = getTransformUnit(propName);
        const defaultVal = stringContains(propName, 'scale') ? 1 : 0 + defaultUnit;
        const str = el.style.transform;
        if (!str) return defaultVal;
        let match = [];
        let props = [];
        dejar valores = [];
        const rgx = /(\w+)\((.+?)\)/g;
        while (match = rgx.exec(str)) {
            props.push(partido[1]);
            valores.push(partido[2]);
        }
        const value = filterArray(valores, (val, i) => props[i] === propName);
        valor de retorno.longitud ? valor[0] : defaultVal;
    }

    función getOriginalTargetValue(target, propName) {
        switch (getAnimationType(target, propName)) {
            case 'transform':
                return getTransformValue(target, propName);
                caso 'css': devuelve getCSSValue(target, propName);
            case 'attribute':
                return target.getAttribute(propName);
        }
        objetivo de retorno[propName] || 0;
    }

    función getRelativeValue(to, from) {
        operador
        const = /^(\*=|\+=|-=)/.exec(to);
        si(!operador) vuelve a;
        const u = getUnit(to) || 0;
        const x = parseFloat(desde);
        const y = parseFloat(to.replace(operador[0], ''));
        conmutador(operador[0][0]) {
            case '+':
                devuelve x + y + u;
                caso '-': retorno x - y + u;
                caso '*': retorno x * y + u;
        }
    }

    función validateValue(val, unit) {
        if (is.col(val)) devuelve colorToRgb(val);
        const originalUnit = getUnit(val);
        const unitLess = originalUnit ? val.substr(0, val.length - originalUnit.length) : val;
        unidad de retorno && !/ \ s /
        g.test(val) ? unitLess + unit : unitLess;
    }

    // getTotalLength () equivalente para círculo, rect, polilínea, polígono y formas de línea. 
    // adaptado de https://gist.github.com/SebLambla/3e0550c496c236709744

    función getDistance(p1, p2) {
        return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
    }

    función getCircleLength(el) {
        return 2 * Math.PI * el.getAttribute('r');
    }

    función getRectLength(el) {
        return (el.getAttribute('ancho') * 2) + (el.getAttribute('alto') * 2);
    }

    función getLineLength(el) {
        return getDistance({ x: el.getAttribute('x1'), y: el.getAttribute('y1') }, { x: el.getAttribute('x2'), y: el.getAttribute('y2') });
    }

    función getPolylineLength(el) {
        puntos constantes = puntos el.
        dejar totalLength = 0;
        let previousPos;
        for (let i = 0; i < points.numberOfItems; i++) {
            const currentPos = points.getItem(i);
            if (i > 0) totalLength + = getDistance(previousPos, currentPos);
            previousPos = currentPos;
        }
        return totalLength;
    }

    función getPolygonLength(el) {
        puntos constantes = puntos el.
        return getPolylineLength(el) + getDistance(points.getItem(points.numberOfItems - 1), points.getItem(0));
    }

    // Animación de ruta

    función getTotalLength(el) {
        if (el.getTotalLength) devuelve el.getTotalLength();
        switch (el.tagName.toLowerCase()) {
            case 'circle':
                return getCircleLength(el);
            case 'rect':
                return getRectLength(el);
            case 'line':
                return getLineLength(el);
            case 'polyline':
                return getPolylineLength(el);
            case 'polygon':
                return getPolygonLength(el);
        }
    }

    función setDashoffset(el) {
        const pathLength = getTotalLength(el);
        el.setAttribute('stroke-dasharray', pathLength);
        camino de retorno Longitud;
    }

    // ruta de movimiento

    función getPath(ruta, porcentaje) {
        const el = is.str(ruta) ? selectString(ruta)[0] : ruta;
        const p = porcentaje || 100;
        función de retorno(prop) {
            regreso {
                el: el,
                propiedad: prop,
                totalLength: getTotalLength(el) * (p / 100)
            }
        }
    }

    función getPathProgress(ruta, progreso) {
        punto de función(desplazamiento = 0) {
            const l = progreso + desplazamiento > = 1 ? progreso + desplazamiento : 0;
            return path.el.getPointAtLength(l);
        }
        const p = punto();
        const p0 = punto(-1);
        const p1 = punto(+1);
        switch (path.property) {
            caso 'x': devuelve px;
            caso 'y': retorno py;
            case 'angle':
                return Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;
        }
    }

    // Descomponer valor

    función decomposeValue(val, unit) {
        const rgx = /-?\d*\.?\d+/g;
        const value = validateValue((is.pth(val) ? val.totalLength : val), unit) + '';
        regreso {
            Valor original,
            números: value.match(rgx) ? value.match(rgx).map(Número) : [0],
                cadenas: (is.str(val) || unit) ? value.split(rgx) : []
        }
    }

    // Animatables

    función parseTargets(objetivos) {
        const TargetArray = objetivos ? (flattenArray(is.arr(objetivos) ? targets.map(toArray) : toArray(objetivos))) : [];
        return filterArray(TargetArray, (item, pos, self) => self.indexOf(item) === pos);
    }

    función getAnimatables(objetivos) {
        const parsed = parseTargets(objetivos);
        return parsed.map((t, i) => {
            return { target: t, id: i, total: parsed.length };
        });
    }

    // Propiedades

    función normalizePropertyTweens(prop, tweenSettings) {
        dejar configuración = cloneObject(tweenSettings);
        if (is.arr(prop)) {
            const l = longitud prop.
            const isFromTo = (l === 2 && !is.obj(prop[0]));
            if (!isFromTo) {
                // Duración dividida por el número de interpolaciones
                if (!is.fnc(tweenSettings.duration)) settings.duration = tweenSettings.duration / l;
            }
            más {
                // Transforma los valores de [from, to] a un valor de interpolación válido
                prop = { valor: prop };
            }
        }
        regrese a Array(prop).map((v, i) => {
            // El valor de retraso predeterminado debe aplicarse solo en la primera interpolación
            const delay = !i ? tweenSettings.delay : 0;
            // Usa el objeto de ruta como un valor de interpolación
            let obj = is.obj(v) && !is.pth(v) ? v : { valor: v };
            // Establecer el valor de retraso predeterminado
            if (is.und(obj.delay)) obj.delay = delay;
            volver obj;
        }).map(k => mergeObjects(k, configuración));
    }

    función getProperties(instanceSettings, tweenSettings, params) {
        let propiedades = [];
        const settings = mergeObjects(instanceSettings, tweenSettings);
        para(deje p en params) {
            if (!settings.hasOwnProperty(p) && p! == 'objetivos') {
                propiedades.push({
                    nombre: p,
                    offset: configuración['offset'],
                    interpolaciones: normalizePropertyTweens(params[p], tweenSettings)
                });
            }
        }
        devolver propiedades;
    }

    // preadolescentes

    función normalizeTweenValues​​(tween, animatable) {
        dejar t = {};
        para(deje p en interpolación) {
            let value = getFunctionValue(interpolación[p], animable);
            if (is.arr(value)) {
                value = value.map(v => getFunctionValue(v, animable));
                if (value.length === 1) valor = valor[0];
            }
            t[p] = valor;
        }
        t.duration = parseFloat(t.duration);
        t.delay = parseFloat(t.delay);
        volver t;
    }

    función normalizeEasing(val) {
        return is.arr(val) ? bezier.apply(this, val) : easings[val];
    }

    función normalizeTweens(prop, animatable) {
        let previousTween;
        volver prop.tweens.map(t => {
            let tween = normalizeTweenValues​​(t, animatable);
            const tweenValue = tween.value;
            const originalValue = getOriginalTargetValue(animatable.target, prop.name);
            const previousValue = previousTween ? previousTween.to.original : originalValue;
            const desde = is.arr(tweenValue) ? tweenValue[0] : previousValue;
            const to = getRelativeValue(is.arr(tweenValue) ? tweenValue[1] : tweenValue, from);
            unidad
            const = getUnit(to) || getUnit(desde) || getUnit(originalValue);
            tween.from = decomposeValue(from, unit);
            tween.to = decomposeValue(to, unit);
            tween.start = previousTween ? previousTween.end : prop.offset;
            tween.end = tween.start + tween.delay + tween.duration;
            tween.easing = normalizeEasing(tween.easing);
            tween.elasticity = (1000 - minMaxValue(tween.elasticity, 1, 999)) / 1000;
            tween.isPath = is.pth(tweenValue);
            tween.isColor = is.col(tween.from.original);
            if (tween.isColor) tween.round = 1;
            previousTween = interpolación;
            interpolación de retorno;
        });
    }

    // Progreso de interpolación

    const setTweenProgress = {
        css: (t, p, v) => t.style[p] = v,
        atributo: (t, p, v) => t.setAttribute(p, v),
        objeto: (t, p, v) => t[p] = v,
        transformar: (t, p, v, transformaciones, id) => {
            si(!transforma[id]) transforma[id] = [];
            transforma[id].push(`$ {p} ($ {v})`);
        }
    }

    // animaciones

    función createAnimation(animable, prop) {
        const animType = getAnimationType(animatable.target, prop.name);
        if (animType) {
            const tweens = normalizeTweens(prop, animable);
            regreso {
                tipo: animType,
                propiedad: prop.name,
                animable: animable,
                interpolaciones: interpolaciones,
                duración: tweens[tweens.length - 1].end,
                retraso: interpolaciones[0].delay
            }
        }
    }

    función getAnimations(animables, propiedades) {
        return filterArray(flattenArray(animatables.map(animatable => {
            return properties.map(prop => {
                return createAnimation(animable, prop);
            });
        })), a => !is.und(a));
    }

    // Crear instancia

    función getInstanceTimings(tipo, animaciones, instanciaSettings, tweenSettings) {
        const isDelay = (type === 'delay');
        if (animaciones.length) {
            return (isDelay ? Math.min : Math.max).apply(Math, animations.map(anim => anim[type]));
        }
        más {
            volver es demora ? tweenSettings.delay : instanceSettings.offset + tweenSettings.delay + tweenSettings.duration;
        }
    }

    función createNewInstance(params) {
        const instanceSettings = replaceObjectProps(defaultInstanceSettings, params);
        const tweenSettings = replaceObjectProps(defaultTweenSettings, params);
        const animatables = getAnimatables(params.targets);
        propiedades
        const = getProperties(instanceSettings, tweenSettings, params);
        animaciones constantes = getAnimations(animables, propiedades);
        return mergeObjects(instanceSettings, {
            niños: [],
            animatables: animatables,
            animaciones: animaciones,
            duración: getInstanceTimings('duración', animaciones, instanciaSettings, tweenSettings),
            delay: getInstanceTimings('delay', animaciones, instanceSettings, tweenSettings)
        });
    }

    // Core

    let activeInstances = [];
    dejar raf = 0;

    const engine = (() => {
        función play() { raf = requestAnimationFrame(paso); };
        paso de función(t) {
            const activeLength = activeInstances.length;
            if (activeLength) {
                dejar i = 0;
                while (i < activeLength) {
                    if (activeInstances[i]) activeInstances[i].tick(t);
                    i++;
                }
                jugar();
            }
            más {
                cancelAnimationFrame(raf);
                raf = 0;
            }
        }
        volver a jugar;
    })();


    // Instancia pública

    función anime(params = {}) {

        ahora,
        startTime,
        lastTime = 0;

        dejar resolver = nulo;

        función makePromise() {
            ventana de retorno.Promesa && nueva promesa(_resolve => resolve = _resolve);
        }

        let promise = makePromise();

        let instancia = createNewInstance(params);

        función toggleInstanceDirection() {
            instancia.reversed = !instancia.reversed;
        }

        función ajustar el tiempo(tiempo) {¿
            instancia de retorno invertida ? instancia.duración - tiempo : tiempo;
        }

        function syncInstanceChildren(hora) {
            const children = instance.children;
            const childrenLength = children.length;
            if (time > = instance.currentTime) {
                for (let i = 0; i < childrenLength; i++) children[i].seek(time);
            }
            más {
                for (let i = childrenLength; i--;) children[i].seek(time);
            }
        }

        función setAnimationsProgress(insTime) {
            dejar i = 0;
            let transforma = {};
            animaciones constantes = instancia.animaciones;
            const animationsLength = animations.length;
            while (i < animationsLength) {
                const anim = animaciones[i];
                const animatable = anim.animatable;
                const tweens = anim.tweens;
                const tweenLength = tweens.length - 1;
                let tween = tweens[tweenLength];
                // Verifique solo los fotogramas clave si hay más de una interpolación
                if (tweenLength) tween = filterArray(interpolaciones, t => (insTime < t.end))[0] || interpolación
                const transcurrido = minMaxValue(insTime - tween.start - tween.delay, 0, tween.duration) / tween.duration;
                const eased = isNaN(transcurrido) ? 1 : tween.easing(transcurrido, tween.elasticity);
                const strings = tween.to.strings;
                const round = tween.round;
                dejar números = [];
                dejar progresar;
                const toNumbersLength = tween.to.numbers.length;
                for (let n = 0; n < toNumbersLength; n++) {
                    dejar valor;
                    const toNumber = tween.to.numbers[n];
                    const fromNumber = tween.from.numbers[n];
                    if (!tween.isPath) {
                        valor = fromNumber + (facilitado * (toNumber - fromNumber));
                    }
                    más {
                        valor = getPathProgress(tween.value, facilitado * aNúmero);
                    }
                    si(redondo) {
                        if (!(tween.isColor && n > 2)) {
                            valor = Math.round(valor * ronda) / ronda;
                        }
                    }
                    números.push(valor);
                }
                // Manual Array.reduce para mejores actuaciones
                const stringsLength = strings.length;
                if (!stringsLength) {
                    progreso = números[0];
                }
                más {
                    progreso = cadenas[0];
                    for (let s = 0; s < stringsLength; s++) {
                        const a = cadenas[s];
                        const b = cadenas[s + 1];
                        const n = números[s];
                        if (!isNaN(n)) {
                            si(!b) {
                                progreso + = n + '';
                            }
                            más {
                                progreso + = n + b;
                            }
                        }
                    }
                }
                setTweenProgress[anim.type](animatable.target, anim.property, progress, transforms, animatable.id);
                anim.currentValue = progreso;
                i++;
            }
            const transformsLength = Object.keys(transformaciones).length;
            si(transformaLongitud) {
                for (let id = 0; id < transformsLength; id++) {
                    if (!transformString) {
                        const t = 'transformar';
                        transformString = (getCSSValue(document.body, t) ? t : `-webkit - $ {t}`);
                    }
                    instance.animatables[id].target.style[transformString] = transforma[id].join('');
                }
            }
            instance.currentTime = insTime;
            instance.progress = (insTime / instance.duration) * 100;
        }

        función setCallback(cb) {
            if (instancia[cb]) instancia[cb](instancia);
        }

        función countIteration() {
            if (instance.remaining && instance.remaining! == verdadero) {
                instancia restante;
            }
        }

        función setInstanceProgress(engineTime) {
            const insDuration = instance.duration;
            const insOffset = instancia.offset;
            const insStart = insOffset + instance.delay;
            const insCurrentTime = instancia.currentTime;
            const insReversed = instancia.reversed;
            const insTime = ajustarTime(engineTime);
            if (instance.children.length) syncInstanceChildren(insTime);
            if (insTime > = insStart || !insDuration) {
                if (!instance.began) {
                    instance.began = true;
                    setCallback('comenzar');
                }
                setCallback('ejecutar');
            }
            if (insTime > insOffset && insTime < insDuration) {
                setAnimationsProgress(insTime);
            }
            más {
                if (insTime <= insOffset && insCurrentTime! == 0) {
                    setAnimationsProgress(0);
                    if (insReversed) countIteration();
                }
                if ((insTime > = insDuration && insCurrentTime! == insDuration) || !insDuration) {
                    setAnimationsProgress(insDuration);
                    if (!insReversed) countIteration();
                }
            }
            setCallback('actualización');
            if (engineTime > = insDuration) {
                if (instancia.remaining) {
                    startTime = ahora;
                    if (instance.direction === 'alternate') toggleInstanceDirection();
                }
                más {
                    instancia.pausa();
                    if (!instance.completed) {
                        instance.completed = true;
                        setCallback('completo');
                        if ('Promesa'
                            en la ventana) {
                            resolver();
                            promesa = makePromise();
                        }
                    }
                }
                lastTime = 0;
            }
        }

        instance.reset = function() {
            dirección constante = instancia.dirección;
            const loops = instancia.loop;
            instance.currentTime = 0;
            instancia.progreso = 0;
            instancia.pausado = verdadero;
            instance.began = false;
            instancia.completado = falso;
            instancia.reversed = direction === 'reverse';
            instance.remaining = direction === 'alternate' && loops === 1 ? 2 : bucles;
            setAnimationsProgress(0);
            for (let i = instance.children.length; i--;) {
                instancia.niños[i].reset();
            }
        }

        instancia.tick = función(t) {
            ahora = t;
            if (!startTime) startTime = ahora;
            const engineTime = (lastTime + now - startTime) * anime.speed;
            setInstanceProgress(engineTime);
        }

        instancia.seek = función(tiempo) {
            setInstanceProgress(ajustarTiempo(tiempo));
        }

        instancia.pausa = función() {
            const i = activeInstances.indexOf(instancia);
            if (i > -1) activeInstances.splice(i, 1);
            instancia.pausado = verdadero;
        }

        instance.play = function() {
            if (!instance.paused) return;
            instancia.pausado = falso;
            startTime = 0;
            lastTime = ajustarTime(instance.currentTime);
            activeInstances.push(instancia);
            si(!raf) motor();
        }

        instance.reverse = function() {
            toggleInstanceDirection();
            startTime = 0;
            lastTime = ajustarTime(instance.currentTime);
        }

        instance.restart = function() {
            instancia.pausa();
            instancia.reset();
            instancia.play();
        }

        instancia.acabado = promesa;

        instancia.reset();

        if (instance.autoplay) instance.play();

        instancia de retorno;

    }

    // Eliminar objetivos de la animación

    función removeTargets(objetivos) {
        const objetivosArray = parseTargets(objetivos);
        for (let i = activeInstances.length; i--;) {
            const instancia = activeInstances[i];
            animaciones constantes = instancia.animaciones;
            for (let a = animations.length; a--;) {
                if (arrayContains(TargetArray, animaciones[a].animatable.target)) {
                    animaciones.plice(a, 1);
                    if (!animations.length) instance.pause();
                }
            }
        }
    }

    // Cronología

    función de línea de tiempo(params) {
        let tl = anime(params);
        tl.pause();
        tl.duration = 0;
        tl.add = function(instanciaParams) {
            tl.children.forEach(i => {
                i.began = true;
                i.completed = true;
            });
            toArray(instanceParams).forEach(instanceParams => {
                let insParams = mergeObjects(instanceParams, replaceObjectProps(defaultTweenSettings, params || {}));
                insParams.targets = insParams.targets || params.targets;
                const tlDuration = tl.duration;
                const insOffset = insParams.offset;
                insParams.autoplay = false;
                insParams.direction = tl.direction;
                insParams.offset = is.und(insOffset) ? tlDuration : getRelativeValue(insOffset, tlDuration);
                tl.began = true;
                tl.completed = true;
                tl.seek(insParams.offset);
                const ins = anime(insParams);
                ins.began = true;
                ins.completed = true;
                if (ins.duration > tlDuration) tl.duration = ins.duration;
                tl.children.push(ins);
            });
            tl.seek(0);
            tl.reset();
            if (tl.autoplay) tl.restart();
            volver tl;
        }
        volver tl;
    }

    anime.version = '2.2.0';
    anime.speed = 1;
    anime.running = activeInstances;
    anime.remove = removeTargets;
    anime.getValue = getOriginalTargetValue;
    anime.path = getPath;
    anime.setDashoffset = setDashoffset;
    anime.bezier = bezier;
    anime.easings = easings;
    anime.timeline = línea de tiempo;
    anime.random = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

    volver anime;

}));